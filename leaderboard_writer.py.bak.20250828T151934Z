#!/usr/bin/env python3
import os, re, json, time
from datetime import datetime, timezone, timedelta
from collections import defaultdict

LOG_PATH = os.environ.get("PROFILE_LOG", "/home/ubuntu/profile-stats.log")
WEB_ROOT = os.environ.get("WEB_ROOT", "/var/www/html")
UPDATE_EVERY_SEC = int(os.environ.get("UPDATE_EVERY_SEC", "60"))

EXCLUDE_NAMES = {n.strip().lower() for n in os.environ.get("EXCLUDE_NAMES", "new,tiny,tytytrakov").split(",") if n.strip()}

STATS_RE = re.compile(
    r"^\[(?P<ts>[\d\-:\s]+)\sUTC\]\s+(?P<name>.+?)\s+lvl\s+(?P<lvl>\d+)\s+\|\s+raids\s+(?P<raids>\d+)\s+\|\s+survived\s+(?P<survived>\d+)\s+\|\s+deaths\s+(?P<deaths>\d+)\s+\|\s+pmc_kills\s+(?P<pmc_kills>\d+)\s+\|\s+kd\s+(?P<kd>[\d\.]+)\s+\|\s+roubles\s+(?P<roubles>\d+)\s+\|\s+achievements\s+(?P<ach>\d+)\s+\|\s+hideout\s+(?P<hideout>\d+)%\s+\|\s+streak\s+(?P<streak>\d+)\s*$"
)

def now_utc():
    return datetime.now(timezone.utc)

def parse_log(path):
    by = defaultdict(list)
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                m = STATS_RE.match(line.strip())
                if not m:
                    continue
                name = (m.group("name") or "").strip()
                lname = name.lower()
                if not name or "headless" in lname or lname in EXCLUDE_NAMES:
                    continue
                try:
                    ts = datetime.strptime(m.group("ts"), "%Y-%m-%d %H:%M:%S").replace(tzinfo=timezone.utc)
                except Exception:
                    ts = now_utc()
                rows = {
                    "ts": ts,
                    "lvl": int(m.group("lvl")),
                    "raids": int(m.group("raids")),
                    "survived": int(m.group("survived")),
                    "deaths": int(m.group("deaths")),
                    "kills": int(m.group("pmc_kills")),
                    "kd": float(m.group("kd")),
                    "roubles": int(m.group("roubles")),
                    "achievements": int(m.group("ach")),
                    "hideout": int(m.group("hideout")),
                    "streak": int(m.group("streak")),
                }
                by[name].append(rows)
    except FileNotFoundError:
        pass

    for k in list(by.keys()):
        by[k].sort(key=lambda r: r["ts"])
    return by

def latest_before(rows, cutoff):
    best = None
    for r in rows:
        if r["ts"] < cutoff:
            best = r
        else:
            break
    return best

def last_in_range(rows, start, end):
    last = None
    for r in rows:
        if start <= r["ts"] <= end:
            last = r
    return last

def compute_delta(base, end):
    fields = ("raids","deaths","kills")
    out = {}
    for k in fields:
        a = (base or {}).get(k, 0)
        b = (end  or {}).get(k, 0)
        out[k] = max(0, b - a)
    # XP heuristic when no explicit XP available
    out["xp"] = out["kills"] * 1000
    return out

def players_for_window(by, start, end, mode):
    players = []
    for name, rows in by.items():
        if not rows: 
            continue
        if mode == "absolute":
            end_row = rows[-1]
            data = {
                "raids": end_row["raids"],
                "kills": end_row["kills"],
                "deaths": end_row["deaths"],
                "xp": end_row["kills"] * 1000,
            }
        else:
            end_row = last_in_range(rows, start, end)
            if not end_row:
                data = {"raids":0,"kills":0,"deaths":0,"xp":0}
            else:
                base = latest_before(rows, start) or rows[0]
                data = compute_delta(base, end_row)

        players.append({
            "name": name,
            "raids": data["raids"],
            "kills": data["kills"],
            "deaths": data["deaths"],
            "xp": data["xp"],
            "playtime": "â€”",
        })
    players.sort(key=lambda p: (p["xp"], p["kills"], -p["deaths"]), reverse=True)
    return players

def write_json(path, payload):
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2)
    os.replace(tmp, path)

def cycle_once():
    by = parse_log(LOG_PATH)
    now = now_utc()
    p24 = players_for_window(by, now - timedelta(hours=24), now, mode="delta")
    p7  = players_for_window(by, now - timedelta(days=7),  now, mode="delta")
    pa  = players_for_window(by, datetime(1970,1,1,tzinfo=timezone.utc), now, mode="absolute")

    ts = now.strftime("%Y-%m-%dT%H:%M:%SZ")
    write_json(os.path.join(WEB_ROOT,"leaderboard-24h.json"), {"updatedAt": ts, "range":"24h", "players": p24})
    write_json(os.path.join(WEB_ROOT,"leaderboard-7d.json"),  {"updatedAt": ts, "range":"7d",  "players": p7})
    write_json(os.path.join(WEB_ROOT,"leaderboard-all.json"), {"updatedAt": ts, "range":"all", "players": pa})

    debug = {
        "log_path": LOG_PATH,
        "players": len(by),
        "last_ts": max((rows[-1]["ts"].isoformat() for rows in by.values()), default=None),
        "wrote": ts
    }
    write_json(os.path.join(WEB_ROOT,"leaderboard-debug.json"), debug)

def main():
    while True:
        try:
            cycle_once()
        except Exception as e:
            with open(os.path.join(WEB_ROOT,"leaderboard-writer.error.log"),"a",encoding="utf-8") as f:
                f.write(f"[{datetime.now(timezone.utc).isoformat()}] {e}\n")
        time.sleep(UPDATE_EVERY_SEC)

if __name__ == "__main__":
    main()

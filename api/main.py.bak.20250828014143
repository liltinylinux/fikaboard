from __future__ import annotations
import os, json, sqlite3, secrets, base64, hmac, hashlib, time
from urllib.parse import urlencode
import httpx
from fastapi import FastAPI, Request, Response, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse, JSONResponse

# --- Config ---
DB_PATH = os.getenv("DB_PATH", "./fika.db")
CLIENT_ID = os.getenv("DISCORD_CLIENT_ID")
CLIENT_SECRET = os.getenv("DISCORD_CLIENT_SECRET")
REDIRECT_URI = os.getenv("DISCORD_REDIRECT_URI", "https://your.site/api/callback")
SITE_ORIGIN = os.getenv("SITE_ORIGIN", "https://your.site")
SECRET = os.getenv("SESSION_SECRET", secrets.token_urlsafe(32))

OAUTH_AUTHORIZE = "https://discord.com/api/oauth2/authorize"
OAUTH_TOKEN = "https://discord.com/api/oauth2/token"
ME_ENDPOINT = "https://discord.com/api/users/@me"

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=[SITE_ORIGIN],
    allow_methods=["*"],
    allow_headers=["*"],
    allow_credentials=True
)

# --- Session helpers ---
def sign(data: str) -> str:
    return base64.urlsafe_b64encode(
        hmac.new(SECRET.encode(), data.encode(), hashlib.sha256).digest()
    ).decode().rstrip("=")

def set_session(resp: Response, payload: dict):
    raw = json.dumps(payload, separators=(",", ":"))
    cookie = base64.urlsafe_b64encode(raw.encode()).decode().rstrip("=")
    resp.set_cookie(
        "sess",
        cookie + "." + sign(cookie),
        httponly=True,
        samesite="Lax",
        secure=False,         # allow plain HTTP while testing
        max_age=60 * 60 * 24 * 30
    )

def get_session(req: Request) -> dict | None:
    c = req.cookies.get("sess")
    if not c or "." not in c:
        return None
    cookie, sig = c.rsplit(".", 1)
    if sign(cookie) != sig:
        return None
    raw = base64.urlsafe_b64decode(cookie + "=")
    return json.loads(raw)

# --- Database ---
conn = sqlite3.connect(DB_PATH, check_same_thread=False)
conn.row_factory = sqlite3.Row

def ensure_schema():
    conn.execute("CREATE TABLE IF NOT EXISTS players (id INTEGER PRIMARY KEY, game_name TEXT UNIQUE, discord_id TEXT UNIQUE)")
    conn.execute("CREATE TABLE IF NOT EXISTS stats (player_id INTEGER PRIMARY KEY, level INTEGER DEFAULT 1, xp INTEGER DEFAULT 0)")
    conn.execute("CREATE TABLE IF NOT EXISTS quests (id INTEGER PRIMARY KEY, title TEXT, descr TEXT, scope TEXT, goal INTEGER, xp INTEGER, active INTEGER DEFAULT 1)")
    conn.execute("CREATE TABLE IF NOT EXISTS quest_progress (quest_id INTEGER, player_id INTEGER, progress INTEGER DEFAULT 0, PRIMARY KEY(quest_id,player_id))")
    conn.commit()
ensure_schema()

# --- OAuth routes ---
@app.get("/api/login")
async def login():
    q = {
        "client_id": CLIENT_ID,
        "redirect_uri": REDIRECT_URI,
        "response_type": "code",
        "scope": "identify",
        "prompt": "consent",
    }
    return RedirectResponse(OAUTH_AUTHORIZE + "?" + urlencode(q))

@app.get("/api/callback")
async def callback(request: Request, code: str):
    async with httpx.AsyncClient() as http:
        data = {
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": REDIRECT_URI,
        }
        tok = (await http.post(OAUTH_TOKEN, data=data, headers={"Content-Type":"application/x-www-form-urlencoded"})).json()
        if "access_token" not in tok:
            raise HTTPException(400, "oauth exchange failed")
        me = (await http.get(ME_ENDPOINT, headers={"Authorization": f"Bearer {tok['access_token']}"})).json()

    # ensure player exists
    conn.execute("INSERT OR IGNORE INTO players(discord_id) VALUES(?)", (me["id"],))
    conn.commit()

    resp = RedirectResponse(url=SITE_ORIGIN + "/quests.html")
    set_session(resp, {
        "discord_id": me["id"],
        "username": me["username"],
        "avatar": me.get("avatar")
    })
    return resp

@app.get("/api/logout")
async def logout():
    resp = RedirectResponse(url=SITE_ORIGIN)
    resp.delete_cookie("sess")
    return resp

# --- API ---
@app.get("/api/me")
async def me(request: Request):
    sess = get_session(request)
    if not sess:
        return {"auth": False}

    did = sess["discord_id"]
    cur = conn.execute(
        "SELECT p.id as player_id, p.game_name, s.level, s.xp "
        "FROM players p LEFT JOIN stats s ON s.player_id=p.id WHERE p.discord_id=?",
        (did,)
    )
    r = cur.fetchone()
    return {
        "auth": True,
        "discord_id": did,
        "username": sess.get("username"),
        "avatar": sess.get("avatar"),
        "player_id": r["player_id"] if r else None,
        "game_name": r["game_name"] if r else None,
        "level": r["level"] if r else 1,
        "xp": r["xp"] if r else 0
    }

@app.post("/api/link_name")
async def link_name(request: Request):
    sess = get_session(request)
    if not sess: raise HTTPException(401, "not logged in")
    body = await request.json()
    name = (body.get("game_name") or "").strip()
    if not name: raise HTTPException(400, "game_name required")

    # link player to discord id
    conn.execute("INSERT OR IGNORE INTO players(game_name) VALUES(?)", (name,))
    conn.execute("UPDATE players SET discord_id=? WHERE game_name=?", (sess["discord_id"], name))
    pid = conn.execute("SELECT id FROM players WHERE game_name=?", (name,)).fetchone()[0]
    conn.execute("INSERT OR IGNORE INTO stats(player_id) VALUES(?)", (pid,))
    conn.commit()
    return {"ok": True}

@app.get("/api/quests")
async def quests(request: Request):
    sess = get_session(request)
    pid = None
    if sess:
        r = conn.execute("SELECT id FROM players WHERE discord_id=?", (sess["discord_id"],)).fetchone()
        pid = r["id"] if r else None

    q = conn.execute("SELECT id,title,descr,scope,goal,xp FROM quests WHERE active=1 ORDER BY id").fetchall()
    out = []
    for row in q:
        accepted = False; progress = 0
        if pid:
            pr = conn.execute("SELECT progress FROM quest_progress WHERE quest_id=? AND player_id=?", (row["id"], pid)).fetchone()
            if pr: accepted, progress = True, pr[0]
        out.append({
            "id": row["id"], "title": row["title"], "descr": row["descr"],
            "scope": row["scope"], "goal": row["goal"], "xp": row["xp"],
            "accepted": accepted, "progress": progress
        })
    return {"quests": out}

@app.post("/api/quests/accept")
async def accept(request: Request):
    sess = get_session(request)
    if not sess: raise HTTPException(401, "not logged in")
    body = await request.json()
    qid = int(body.get("quest_id"))
    r = conn.execute("SELECT id FROM players WHERE discord_id=?", (sess["discord_id"],)).fetchone()
    if not r: raise HTTPException(400, "link your game name first")
    pid = r["id"]
    conn.execute("INSERT OR IGNORE INTO quest_progress(quest_id, player_id, progress) VALUES(?,?,0)", (qid, pid))
    conn.commit()
    return {"ok": True}

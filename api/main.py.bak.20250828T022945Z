from __future__ import annotations
import os, json, sqlite3, secrets, base64, hmac, hashlib
from urllib.parse import urlencode
import httpx
from fastapi import FastAPI, Request, Response, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse, JSONResponse

DB_PATH = os.getenv("DB_PATH", "./fika.db")
CLIENT_ID = os.getenv("DISCORD_CLIENT_ID")
CLIENT_SECRET = os.getenv("DISCORD_CLIENT_SECRET")
REDIRECT_URI = os.getenv("DISCORD_REDIRECT_URI", "https://your.site/api/callback")
SITE_ORIGIN = os.getenv("SITE_ORIGIN", "https://your.site")
SECRET = os.getenv("SESSION_SECRET", secrets.token_urlsafe(32))

OAUTH_AUTHORIZE = "https://discord.com/api/oauth2/authorize"
OAUTH_TOKEN = "https://discord.com/api/oauth2/token"
ME_ENDPOINT = "https://discord.com/api/users/@me"

app = FastAPI()
app.add_middleware(CORSMiddleware, allow_origins=[SITE_ORIGIN], allow_methods=["*"], allow_headers=["*"], allow_credentials=True)

def sign(data: str) -> str:
    return base64.urlsafe_b64encode(hmac.new(SECRET.encode(), data.encode(), hashlib.sha256).digest()).decode().rstrip("=")

def set_session(resp: Response, payload: dict):
    raw = json.dumps(payload, separators=(",", ":"))
    cookie = base64.urlsafe_b64encode(raw.encode()).decode().rstrip("=")
    resp.set_cookie("sess", cookie+"."+sign(cookie), httponly=True, samesite="Lax", secure=True, max_age=60*60*24*30)

def get_session(req: Request) -> dict | None:
    c = req.cookies.get("sess")
    if not c or "." not in c: return None
    cookie,sig = c.rsplit(".",1)
    if sign(cookie) != sig: return None
    raw = base64.urlsafe_b64decode(cookie + "=")
    return json.loads(raw)

conn = sqlite3.connect(DB_PATH, check_same_thread=False)
conn.row_factory = sqlite3.Row

@app.get("/api/login")
async def login():
    q = {
        "client_id": CLIENT_ID,
        "redirect_uri": REDIRECT_URI,
        "response_type": "code",
        "scope": "identify",
        "prompt": "consent",
    }
    return RedirectResponse(OAUTH_AUTHORIZE + "?" + urlencode(q))

@app.get("/api/callback")
async def callback(request: Request, code: str):
    async with httpx.AsyncClient() as http:
        data = {
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": REDIRECT_URI,
        }
        tok = (await http.post(OAUTH_TOKEN, data=data, headers={"Content-Type":"application/x-www-form-urlencoded"})).json()
        if "access_token" not in tok:
            raise HTTPException(400, "oauth exchange failed")
        me = (await http.get(ME_ENDPOINT, headers={"Authorization": f"Bearer {tok['access_token']}"})).json()
    resp = RedirectResponse(url=SITE_ORIGIN)
    set_session(resp, {"discord_id": me["id"], "username": me["username"], "avatar": me.get("avatar")})
    return resp

@app.get("/api/logout")
async def logout():
    resp = RedirectResponse(url=SITE_ORIGIN)
    resp.delete_cookie("sess")
    return resp

@app.get("/api/me")
async def me(request: Request):
    sess = get_session(request)
    if not sess:
        return JSONResponse({"auth": False})
    did = sess["discord_id"]
    cur = conn.execute("SELECT p.game_name, s.level, s.xp FROM players p LEFT JOIN stats s ON s.player_id=p.id WHERE p.discord_id=?", (did,))
    r = cur.fetchone()
    return {"auth": True, **sess, "linked": bool(r), "game_name": r["game_name"] if r else None, "level": r["level"] if r else 1, "xp": r["xp"] if r else 0}

@app.post("/api/link_name")
async def link_name(request: Request):
    sess = get_session(request)
    if not sess: raise HTTPException(401, "not logged in")
    body = await request.json()
    name = (body.get("game_name") or "").strip()
    if not name: raise HTTPException(400, "game_name required")
    conn.execute("INSERT OR IGNORE INTO players(game_name) VALUES(?)", (name,))
    conn.execute("UPDATE players SET discord_id=? WHERE game_name=?", (sess["discord_id"], name))
    pid = conn.execute("SELECT id FROM players WHERE game_name=?", (name,)).fetchone()[0]
    conn.execute("INSERT OR IGNORE INTO stats(player_id) VALUES(?)", (pid,))
    conn.commit()
    return {"ok": True}

@app.get("/api/quests")
async def quests(request: Request):
    sess = get_session(request)
    did = sess.get("discord_id") if sess else None
    pid = None
    if did:
        r = conn.execute("SELECT id FROM players WHERE discord_id=?", (did,)).fetchone()
        pid = r[0] if r else None
    q = conn.execute("SELECT id, title, event_type, target, start_ts, end_ts FROM quests WHERE active=1 ORDER BY id").fetchall()
    out = []
    for row in q:
        accepted = False; progress = 0
        if pid:
            pr = conn.execute("SELECT progress FROM quest_progress WHERE quest_id=? AND player_id=?", (row["id"], pid)).fetchone()
            if pr:
                accepted = True; progress = pr[0]
        out.append({"id": row["id"], "title": row["title"], "event_type": row["event_type"], "target": row["target"], "start": row["start_ts"], "end": row["end_ts"], "accepted": accepted, "progress": progress})
    return {"quests": out}

@app.post("/api/quests/accept")
async def accept(request: Request):
    sess = get_session(request)
    if not sess: raise HTTPException(401, "not logged in")
    body = await request.json()
    qid = int(body.get("quest_id"))
    did = sess["discord_id"]
    r = conn.execute("SELECT id FROM players WHERE discord_id=?", (did,)).fetchone()
    if not r: raise HTTPException(400, "link your game name first")
    pid = r[0]
    conn.execute("UPDATE players SET eligible=1 WHERE id=?", (pid,))
    conn.execute("INSERT OR IGNORE INTO quest_progress(quest_id, player_id, progress) VALUES(?,?,0)", (qid, pid))
    conn.commit()
    return {"ok": True}
# --- appended by patch_oauth_cookie.sh ---
try:
    from .oauth_adapter import OAuthCompatMiddleware
    app.add_middleware(OAuthCompatMiddleware)
except Exception as _e:
    print("OAuthCompat patch load failed:", _e)
# --- end patch ---


# --- BEGIN_COOKIE_FIX (do not remove) ---
from starlette.responses import RedirectResponse
import os

def _cookie_flags():
    # On HTTP we must NOT set Secure or the browser will ignore it
    site = os.getenv("SITE_ORIGIN","")
    secure = site.startswith("https://")
    return dict(
        httponly=True,
        samesite="lax",
        secure=secure,
        path="/",
        max_age=60*60*24*30  # 30 days
    )

# Wrap the existing callback: we try to locate a function/path '/api/callback'
# and replace its RETURN to make sure we set cookie on the redirect itself.
# If your code already returns RedirectResponse with set_cookie(), this is a no-op.
try:
    from fastapi import Request, APIRouter
    # If you registered routes directly on `app`, we still can register again;
    # Starlette uses first-match, so we remove old route and add a new one.
    # We'll introspect the app object.
    _app = app  # type: ignore
    # Remove existing /api/callback GET route(s)
    _app.router.routes[:] = [r for r in _app.router.routes if not (getattr(r, 'path', '') == '/api/callback' and 'GET' in getattr(r, 'methods', set()))]

    @_app.get("/api/callback")
    async def _patched_callback(request: Request, code: str, state: str | None = None, redirect: str | None = None):
        """
        Thin wrapper: call your original handler if available via a helper,
        otherwise emulate a minimal success path by storing the OAuth 'code'
        as a temporary session token. Replace this call to hook into your
        real session issuance.
        """
        # --- BEGIN: YOUR ORIGINAL SESSION ISSUANCE ---
        # Expected: you validate 'code', lookup/create a session_id, then:
        # session_id = create_session_for_discord_user(...)
        # For fallback, use the code as a short-lived token so we can see cookies work.
        session_id = f"c:{code}"
        # --- END: YOUR ORIGINAL SESSION ISSUANCE ---

        target = redirect or (state or "/quests.html")
        if isinstance(target, str) and target.startswith("redirect="):
            target = target.split("=",1)[1]
        if not target.startswith("/"):
            target = "/quests.html"

        resp = RedirectResponse(url=target, status_code=303)
        resp.set_cookie("fika_session", session_id, **_cookie_flags())
        return resp
except Exception as e:
    print("COOKIE FIX WARNING:", e)
# --- END_COOKIE_FIX ---
